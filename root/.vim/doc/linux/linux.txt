vim:ft=help
*linux*

--------------------------------------------------------------------------
Linux发行版 ~

Ubuntu 18.04和CentOS 7 对应
Ubuntu 22.04和CentOS 9 对应   (见OceanBase安装依赖脚本 d714ba809a438602eb6d7b47e9d95c769fd21d93)

--------------------------------------------------------------------------
*trace工具*
`ktrace`, `ptrace`, 和 `strace` 都是与跟踪和监控系统调用和进程执行相关的工具，但它们适用于不同的操作系统和有着不同的用途。

ktrace ~
`ktrace` 是在某些类Unix操作系统上，特别是BSD系统（如FreeBSD、OpenBSD等）中使用的一个工具。它能够跟踪和记录内核和用户空间程序之间的交互，包括系统调用、信号传递等。通过`ktrace`，开发者可以理解程序是如何与操作系统交互的，这对于调试和性能分析非常有用。`ktrace` 生成的跟踪输出通常通过 `kdump` 命令以人类可读的形式查看。

ptrace ~
`ptrace` 是一个Unix和类Unix操作系统的系统调用，允许一个进程观察和控制另一个进程的执行，以及读写其内存和寄存器。它是许多调试工具和系统监控工具背后的底层机制。`ptrace` 提供了一种手段来实现断点、单步执行以及在运行时检查和改变CPU寄存器和内存地址的能力。它是实现像 gdb 这样的调试器的核心功能之一。

strace ~
`strace` 是在Linux和一些其他类Unix系统上用于监控进程系统调用和接收到的信号的工具。它对于理解程序如何与操作系统交云以及诊断运行时问题非常有帮助。`strace` 工作在用户空间，无需特殊的内核模块或支持。它利用了 `ptrace` 系统调用来实现其功能，通过拦截和记录系统调用，可以帮助开发者和系统管理员分析程序行为和性能问题。

总结来说，`ktrace`、`ptrace`和`strace`都是强大的工具，用于分析和调试程序与操作系统之间的交互。它们分别在不同的系统和场景下使用，但目的相似，都是为了提供对程序执行的深入了解。
--------------------------------------------------------------------------
*sudo保留用户当前环境变量* `sudo -E`
*sudo从stdin读取密码，防止脚本被sudo输密码暂停* `echo "mypassword" | sudo -S <command>`

sudo权限限制，防止用户误操作 ~

/etc/sudoers文件中修改%sudo group的权限。

ALL: 允许执行所有命令
!/usr/bin/su: 禁止使用su命令
!/usr/sbin/iptables: 禁止使用iptables命令

权限规则从右向左匹配，匹配到第一个规则后停止（默认是禁止所有命令，沉默即禁止）。
>sudoers
    # CentOS中%sudo改为%wheel
    %sudo   ALL=(ALL:ALL) ALL,!/usr/bin/su,!/usr/sbin/iptables
<

iptables: 误操作可能导致ssh无法连接服务器。

参考资料：
sudoers文件说明 - sudo免密码 - 限制sudo执行特殊命令 - 红色的红的文章 - 知乎
https://zhuanlan.zhihu.com/p/632737024

Linux修改他人用户名 ~

*linux-user*

在Linux中修改他人的用户名涉及到管理员权限。这通常通过使用命令行实现。以下是修改用户名的步骤：

1. 登录为root用户 或者 使用具有sudo权限的用户。

2. 确保要修改的用户没有运行的进程。您可以使用 `pkill` 命令结束所有由该用户运行的进程，例如：
>
   sudo pkill -u oldusername
<
   或者确保该用户已注销或未运行任何进程。

3. 使用`usermod`命令来修改用户名。基本的命令结构是：
>
   sudo usermod -l newusername oldusername
<
   这里 `-l` 参数用于更改用户的登录名。

4. （可选）更改用户的主目录名称。如果您也想更改用户的主目录以匹配新的用户名，可以使用：
>
   sudo usermod -d /home/newusername -m newusername
<
   这里 `-d` 参数用于指定新的主目录，而 `-m` 参数将移动旧主目录中的文件到新目录。

5. （可选）更改用户的邮件目录。如果系统使用邮件服务，并且每个用户都有一个邮件目录，那么您可能还需要更新这个目录的名称。

6. 检查与旧用户名相关的所有配置和权限设置，并进行必要的更新。

请注意，更改用户名可能会影响到用户的配置和权限。建议在执行这些操作之前做好备份，并检查所有与用户相关的服务和应用程序。在生产环境中，此类更改应谨慎进行，以避免任何不必要的服务中断。

*创建用户*
>bash
    # CentOS 创建用户并指定home目录
    sudo useradd -m -d /media/sdb/jiangyinzuo jiangyinzuo
    # 给用户设置密码
    sudo passwd jiangyinzuo
<

*给他人添加sudo权限*

>bash
	# Ubuntu 加入sudo组
	sudo usermod -aG sudo username
	# CentOS 加入wheel组
	sudo usermod -aG wheel username
<
之后打开/etc/sudoers文件，确保%sudo或%wheel组有`ALL=(ALL:ALL) ALL`权限。

*查看一个用户属于哪些组*
>bash
    # 查看自己
    groups
    # 查看"username"用户
    groups username
<
*查看sudo组的成员*

>bash
	getent group sudo
<

手动创建误删除的home目录 ~

>bash
    sudo mkdir /home/username
    sudo chown username:username /home/username
    sudo chmod 700 /home/username
<

打开 `/etc/passwd` 文件，查看对应用户的home目录是否正确。

查看进程 ~

>bash
    # 查看当前用户的进程
    ps
    # 查看所有进程
    ps -ef
<

增加动态链接库查找路径 ~

*LD_LIBRARY_PATH*
>bash
    export LD_LIBRARY_PATH=/your/custom/path:$LD_LIBRARY_PATH
<

----------------------------------

*linux查看重启时间* uptime -p

----------------------------------

*linux程序性能分析*

perf: 只能做函数级别的分析，函数内部无法分析

虽然使用 perf 可以很方便的对程序进行性能评估，但是使用 perf 会对程序的运行产生比较大的 overhead，导致程序运行比较慢；并且 perf 生成的数据量非常大，其后处理需要花费很长的时间，在 brandon 的博客里面也有提到。因此，perf 实际上是不能用在生产环境中的，只能在测试场景下对程序做性能评估。

作者：xxxwwxxx
链接：https://zhuanlan.zhihu.com/p/672082073
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

*perf统计函数被调用堆栈*

用于调用路径统计、代码逻辑理解

>bash
    # 统计正在运行的24114进程，统计调用次数而非运行时间
    sudo perf probe -x /proc/24114/exe 'function_to_probe'
    # 查看现有的probe事件
    sudo perf probe -l
    sudo perf record -p 24114 -e probe_myprogram:function_to_probe --call-graph dwarf -g -- sleep 20
    # 查看报告，默认加载perf.data
    sudo perf report
    # or
    sudo perf report -i perf.data --stdio --header --sort comm,dso,symbol --children > perf-report.txt
    # 或者用FlameGraph处理

    # 删除probe事件
    sudo perf probe -d probe_myprogram:function_to_probe
<

*perf打火焰图*

>bash
    # $perf_pid: 进程
    # $perf_time: 抓取时间
    perf record -F 999 --call-graph dwarf -g -p $perf_pid -- sleep $perf_time

    # 依赖FlameGraph perl脚本：https://github.com/brendangregg/FlameGraph
    # $out: 输出的svg图片，如flame.svg
    perf script -i perf.data | ./FlameGraph/stackcollapse-perf.pl | ./FlameGraph/flamegraph.pl > $out
<
Perf两种主要的栈回溯 (Stack Unwinding) 方式 ~

1. fp (Frame Pointer - 帧指针)

原理：通过CPU寄存器中的帧指针（rbp 寄存器 on x86-64）来遍历调用栈。
优点：开销非常低，速度快。
缺点：现在的编译器为了优化性能，默认会禁用帧指针（例如 gcc 的 -fomit-frame-pointer 优化）。如果你的程序编译时没有保留帧指针，perf 将无法正确回溯，导致调用栈不完整。
解决方法：在编译你的应用程序时，需要加上编译选项 -fno-omit-frame-pointer 来保留帧指针。

2. dwarf (DWARF Debug Info)

原理：利用保存在可执行文件中的 DWARF 调试信息来回溯调用栈。这些信息精确地描述了如何在任何指令地址上回溯堆栈。
优点：非常精确，即使帧指针被优化掉也能工作。
缺点：
- 开销比 fp 模式大。
- 要求可执行文件和库在编译时必须包含调试信息（例如 gcc 的 -g 选项）。
- 需要指定一个栈的抓取大小，如果调用栈太深，超过了这个大小，仍然会被截断。

Intel VTune Profiler ~

*intel-vtune-profiler*

2025后续版本不支持旧的Intel CPU。需要下载2024版本

gperftools (libprofiler, pprof) ~

*gperftools* 侵入式profiler
